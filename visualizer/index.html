<!doctype html>

<meta charset="utf-8">
<title>Dagre D3 Demo: Tooltip on Hover</title>

<link rel="stylesheet" href="demo.css">
<script src="https://d3js.org/d3.v5.min.js" charset="utf-8"></script>
<script src="dagre-d3.js"></script>

<!-- Pull in JQuery dependencies -->
<link rel="stylesheet" href="tipsy.css">
<script src="https://code.jquery.com/jquery-1.9.1.min.js"></script>
<script src="tipsy.js"></script>
<script src="data.js"></script>
<script src="jsnetworkx.js"></script>

<h1>Dagre D3 Demo: Tooltip on Hover</h1>

<style id="css">
text {
  font-weight: 300;
  font-family: "Helvetica Neue", Helvetica, Arial, sans-serf;
  font-size: 14px;
}

.node rect {
  stroke: #333;
  fill: #fff;
}

.edgePath path {
  stroke: #333;
  fill: #333;
  stroke-width: 1.5px;
}

.node text {
  pointer-events: none;
}

/* This styles the title of the tooltip */
.tipsy .name {
  font-size: 1.5em;
  font-weight: bold;
  color: #60b1fc;
  margin: 0;
}

/* This styles the body of the tooltip */
.tipsy .description {
  font-size: 1.2em;
}
</style>

<svg width=960 height=600></svg>

<section>
<p>The TCP state diagram
(<a href="http://www.rfc-editor.org/rfc/rfc793.txt">source: RFC 793</a>) with
hover support. Uses <a href="http://bl.ocks.org/ilyabo/1373263">tipsy JS and CSS</a>
for the tooltip.
</section>

<script id="js">
// Create a new directed graph
var g = nxclean()


var root = data[0].Doi

// Create the renderer
var render = new dagreD3.render();

// Set up an SVG group so that we can translate the final graph.
var svg = d3.select("svg"),
    inner = svg.append("g");

// Set up zoom support
var zoom = d3.zoom()
    .on("zoom", function() {
      inner.attr("transform", d3.event.transform);
    });
svg.call(zoom);

// Simple function to style the tooltip for the given node.
var styleTooltip = function(name, description) {
  return "<p class='name'>" + name + "</p><p class='description'>" + description + "</p>";
};





/*returns a graph constructed directly from the datafile*/
function load_graph() {
  var g = new dagreD3.graphlib.Graph().setGraph({});

  g.graph().rankdir = 'LR';
  g.graph().align = 'DR';
  //g.graph().ranker = 'tight-tree'

  data = data.filter(paper => paper.Citers != null)

  // States and transitions from RFC 793
  var states = data.reduce((dict, paper) => {dict[paper.Doi] = {}; dict[paper.Doi].description = paper.Title ; return dict}, {})

  //console.log(states);

  // Add states to the graph, set labels, and style
  Object.keys(states).forEach(function(state) {
    var value = states[state];
    value.label = " ";
    value.rx = value.ry = 10;
    value.shape = "circle"
    value.style = "fill: #a57"
    g.setNode(state, value);
  });

  var options = {};
  data.filter(paper => paper.Citers != null).forEach(paper => {
      paper.Citers.filter(c => states[c] != null).forEach(citer => {
          g.setEdge(paper.Doi, citer, {curve: d3.curveBasis});
      });
  });

  return g
}

/*Returns a cleaned graph based on cliques*/
function nxclean() {
  data = data.filter(paper => paper.Citers != null)

  // States and transitions from RFC 793
  var states = data.reduce((dict, paper) => {dict[paper.Doi] = {}; dict[paper.Doi].description = paper.Title ; return dict}, {})


  //Make networkx version of the graph
  gx = new jsnx.DiGraph();

  //Add real data for the graph
  Object.keys(states).forEach(function(state) {
    gx.addNode(state);
  });

  data.filter(paper => paper.Citers != null).forEach(paper => {
      paper.Citers.filter(c => states[c] != null).forEach(citer => {
          if (paper.Doi != citer) {
            gx.addEdge(paper.Doi, citer);
          } 
      });
  });

  //Rank nodes for later MUST BE DONE HERE DO NOT MOVE DOWN
  var scource_node = Array.from(gx.inDegreeIter()).filter(el => el[1] == 0)[0][0]
  var sortOrder = jsnx.topologicalSort(gx)

  //Add reverse edges
  data.filter(paper => paper.Citers != null).forEach(paper => {
      paper.Citers.filter(c => states[c] != null).forEach(citer => {
        gx.addEdge(citer, paper.Doi); 
      });
  });  
  

  var cliques_iterator = jsnx.findCliques(gx)

  var cliques = Array.from(cliques_iterator)

  //Sort cliques according to topology order
  const sorter = (a, b) => {
    ia = sortOrder.indexOf(a);
    ib = sortOrder.indexOf(b); 
    if ( ia < ib ) {
        return -1;
    };
    if (ia > ib ) {
      return 1;
    }
    return 0;
  };

  cliques.forEach(clique => {clique.sort(sorter)})


  //Make the actual graph based on cliques
  var g = new dagreD3.graphlib.Graph().setGraph({});

  g.graph().rankdir = 'LR';
  g.graph().align = 'DR';
  
  //Node can be loaded from data
  Object.keys(states).forEach(function(state) {
    var value = states[state];
    value.label = " ";
    value.rx = value.ry = 10;
    value.shape = "circle"
    value.style = "fill: #a57"
    g.setNode(state, value);
  });

  cliques.forEach(clique => {
    var color = getRandomColor() 
    clique.forEach((node, index) => {    
      if ((index + 1) != (clique.length)) {
        if (clique.length == 2) {
          g.setEdge(node, clique[index+1], {curve: d3.curveBasis, style: "stroke-dasharray: 5, 5;"})
        } else {
          g.setEdge(node, clique[index+1], {curve: d3.curveBasis, style: "stroke: "+color+";", arrowheadStyle: "fill: "+color})  
        }
      }
    })
  })

  return g

}

function getRandomColor() {
  var letters = '0123456789ABCDEF';
  var color = '#';
  for (var i = 0; i < 6; i++) {
    color += letters[Math.floor(Math.random() * 16)];
  }
  return color;
}


// Run the renderer. This is what draws the final graph.
render(inner, g);

inner.selectAll("g.node")
  .attr("title", function(v) { return styleTooltip(v, g.node(v).description) })
  .each(function(v) { $(this).tipsy({ gravity: "w", opacity: 1, html: true }); });

// Center the graph
var initialScale = 0.75;
svg.call(zoom.transform, d3.zoomIdentity.translate((svg.attr("width") - g.graph().width * initialScale) / 2, 20).scale(initialScale));

svg.attr('height', g.graph().height * initialScale + 40);
</script>

<script src="demo.js"></script>