<!doctype html>

<meta charset="utf-8">
<title>Dagre D3 Demo: Tooltip on Hover</title>

<link rel="stylesheet" href="demo.css">
<script src="https://d3js.org/d3.v5.min.js" charset="utf-8"></script>
<script src="dagre-d3.js"></script>

<!-- Pull in JQuery dependencies -->
<link rel="stylesheet" href="tipsy.css">
<script src="https://code.jquery.com/jquery-1.9.1.min.js"></script>
<script src="tipsy.js"></script>
<script src="data.js"></script>
<script src="jsnetworkx.js"></script>
<script src="loadData.js"></script>

<h1>Dagre D3 Demo: Tooltip on Hover</h1>

<style id="css">
text {
  font-weight: 300;
  font-family: "Helvetica Neue", Helvetica, Arial, sans-serf;
  font-size: 14px;
}

.node rect {
  stroke: #333;
  fill: #fff;
}

.edgePath path {
  stroke: #333;
  fill: #333;
  stroke-width: 1.5px;
}

.node text {
  pointer-events: none;
}

/* This styles the title of the tooltip */
.tipsy .name {
  font-size: 1.5em;
  font-weight: bold;
  color: #60b1fc;
  margin: 0;
}

/* This styles the body of the tooltip */
.tipsy .description {
  font-size: 1.2em;
}
</style>

<label for="author">Author:</label><input id="author" />
<button id="authorButton" >
  Fetch Authors papers
</button><br />
<label for="layers">Layers:</label><input id="layers" value="3" /><br />

<select id="selectPaper">
  <option></option>
</select>
<button id="selectPaperButton">
  Select Paper
</button>
<br /><br />
<span id="count"></span>/<span id="total"></span>

<svg width=960 height=600></svg>

<script>
data = data.filter(paper => paper.Citers != null)
// Create the renderer
var render = new dagreD3.render();

// Set up an SVG group so that we can translate the final graph.
var svg = d3.select("svg"),
    inner = svg.append("g");

var authorElement = document.getElementById('author');
var selectPaperElement = document.getElementById('selectPaper');
var layersElement = document.getElementById('layers')

var authorButtonElement = document.getElementById('authorButton');
authorButtonElement.addEventListener("click", () => GetPapersFromAuthor(authorElement.value, selectPaperElement));

var selectPaperButtonElement = document.getElementById('selectPaperButton');
selectPaperButtonElement.addEventListener("click", () => {
  data = [];
  count = 0;
  total = 1;
  document.getElementById('count').innerHTML = count;
  document.getElementById('total').innerHTML = total;
  svg.innerHtml = '';
  LoadPaper(selectPaperElement.value, layersElement.value, infoCallback, citersCallback, updateGraphCallback);
});

// Create a new directed graph
var g = nxclean()

// Run the renderer. This is what draws the final graph.
render(inner, g);

function updateGraphCallback() {
  data = data.filter(paper => paper.Citers != null);
  g = nxclean();
  render(inner, g);
  inner.selectAll("g.node")
    .attr("title", function(v) { return styleTooltip(v, g.node(v).description) })
    .each(function(v) { $(this).tipsy({ gravity: "w", opacity: 1, html: true }); });
}

function infoCallback(doi, title) {
  if (!data.map(p => p.Doi).includes(doi)) {
    data.push({Doi: doi, Title: title, Citers: null})
  } else {
    data.filter(p => p.Doi == doi)[0].Title = title
  }
  g = nxclean()
  render(inner, g);
}

function citersCallback(doi, citers) {
  if (!data.map(p => p.Doi).includes(doi)) {
    data.push({Doi: doi, Citers: citers})
  } else {
    data.filter(p => p.Doi == doi)[0].Citers = citers
  }
}


// Set up zoom support
var zoom = d3.zoom()
    .on("zoom", function() {
      inner.attr("transform", d3.event.transform);
    });
svg.call(zoom);

// Simple function to style the tooltip for the given node.
var styleTooltip = function(name, description) {
  return "<p class='name'>" + description + "</p><p class='description'>" + name + "</p>";
};





/*returns a graph constructed directly from the datafile*/
function load_graph() {
  var g = new dagreD3.graphlib.Graph().setGraph({});

  g.graph().rankdir = 'LR';
  g.graph().align = 'DR';
  //g.graph().ranker = 'tight-tree'
  
  var states = data.reduce((dict, paper) => {dict[paper.Doi] = {}; dict[paper.Doi].description = paper.Title ; return dict}, {})

  // Add states to the graph, set labels, and style
  Object.keys(states).forEach(function(state) {
    var value = states[state];
    value.label = " ";
    value.rx = value.ry = 10;
    value.shape = "circle"
    value.style = "fill: #a57"
    g.setNode(state, value);
  });

  var options = {};
  data.filter(paper => paper.Citers != null).forEach(paper => {
      paper.Citers.filter(c => states[c] != null).forEach(citer => {
          g.setEdge(paper.Doi, citer, {curve: d3.curveBasis});
      });
  });

  return g
}

/*Returns a cleaned graph based on cliques*/
function nxclean() {
  //Load dagre graph
  var gd = load_graph()


  //Make networkx version of the graph
  gx = new jsnx.DiGraph();
  
  var states = data.reduce((dict, paper) => {dict[paper.Doi] = {}; dict[paper.Doi].description = paper.Title ; return dict}, {})

  //Add nodes directly from the data
  Object.keys(states).forEach(function(state) {
    gx.addNode(state);
  });

  //Add only edges from the cleaned dagre graph
  gd.edges().forEach(edge =>{
    //if (edge['v'] != edge['w']) {
      gx.addEdge(edge['v'],edge['w'])
    //}
  });

  /*data.filter(paper => paper.Citers != null).forEach(paper => {
      paper.Citers.filter(c => states[c] != null).forEach(citer => {
          if (paper.Doi != citer) {
            gx.addEdge(paper.Doi, citer);
          } 
      });
  });*/

  //Rank nodes for later MUST BE DONE HERE DO NOT MOVE DOWN
  var source_node = Array.from(gx.inDegreeIter()).filter(el => el[1] == 0)[0][0]
  var adjecencyMap = makeAdjecencyMap(gx)

  gx.nodes().forEach( node => findCycles(adjecencyMap, node, {}, node, gx))
  //var cycles = findCycles(adjecencyMap, source_node, visited, source_node)
  //console.log(visited)
  var sortOrder = jsnx.topologicalSort(gx)
  
  //Add reverse edges
  gx.edges().forEach(edge =>
    gx.addEdge(edge[1],edge[0])
  )

  /*data.filter(paper => paper.Citers != null).forEach(paper => {
      paper.Citers.filter(c => states[c] != null).forEach(citer => {
        gx.addEdge(citer, paper.Doi); 
      });
  });*/  
  

  var cliques_iterator = jsnx.findCliques(gx)

  var cliques = Array.from(cliques_iterator)

  //Sort cliques according to topology order
  const sorter = (a, b) => {
    ia = sortOrder.indexOf(a);
    ib = sortOrder.indexOf(b); 
    if ( ia < ib ) {
        return -1;
    };
    if (ia > ib ) {
      return 1;
    }
    return 0;
  };

  cliques.forEach(clique => {clique.sort(sorter)})


  //Make the actual graph based on cliques
  var g = new dagreD3.graphlib.Graph({compound:true}).setGraph({});

  g.graph().rankdir = 'LR';
  g.graph().align = 'DR';
  
  //Node can be loaded from data
  Object.keys(states).forEach(function(state) {
    var value = states[state];
    value.label = " ";
    value.rx = value.ry = 10;
    value.shape = "circle"
    value.style = "fill: #a57"
    g.setNode(state, value);
  });

  cliques.forEach(clique => {
    var color = getRandomColor()
    clique.forEach((node, index) => {   
      if ((index + 1) != (clique.length)) {
        if (clique.length == 2) {
          g.setEdge(node, clique[index+1], {curve: d3.curveBasis, style: "stroke-dasharray: 5, 5;"})
        } else {
          g.setEdge(node, clique[index+1], {curve: d3.curveBasis, style: `stroke: ${color}; stroke-width: 3;`, arrowheadStyle: `fill: ${color}`})  
        }
      }
    })
  })

  function compareLength(a, b) {
    if ( a.length < b.length ){
      return -1;
    }
    if ( a.length > b.length ){
      return 1;
    }
    return 0;
  }

  g.setNode("mainGroup", {style: `fill: white`})
  cliques.sort(compareLength).reverse()[0].forEach((node, index) => {
    g.setParent(node, "mainGroup");
  });

  return g

}

function getRandomColor() {
  var letters = '0123456789ABCDEF';
  var color = '#';
  for (var i = 0; i < 6; i++) {
    color += letters[Math.floor(Math.random() * 16)];
  }
  return color;
}

function makeAdjecencyMap(gx) {
  var adj = new Map()
  gx.nodes().forEach(node => {
    adj[node] = jsnx.neighbors(gx, node)
  })
  return adj
}


function findCycles(adj, node, visited, start, graph) {
  if (visited[node]) {
    if (node == start){
      return true
    } 
    return false; 
  } 
  visited[node]=true;      
  adj[node].forEach(child => {
    if (findCycles(adj,child,visited, start, graph)){
      gx.edges().some(e => {
        if (e[0] == node && e[1] == child) {
          graph.removeEdge(e[0],e[1])
          return true
        }
        if (e[1] == node && e[0] == child) {
          graph.removeEdge(e[1],e[0])
          return true
        } 
        return false  
      })
    }
  })     
  visited[node]=false;
}


inner.selectAll("g.node")
  .attr("title", function(v) { return styleTooltip(v, g.node(v).description) })
  .each(function(v) { $(this).tipsy({ gravity: "w", opacity: 1, html: true }); });

// Center the graph
var initialScale = 0.75;
svg.call(zoom.transform, d3.zoomIdentity.translate((svg.attr("width") - g.graph().width * initialScale) / 2, 20).scale(initialScale));

svg.attr('height', g.graph().height * initialScale + 40);
</script>